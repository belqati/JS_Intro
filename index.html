<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JS Notes</title>
  <link rel="icon" type="image/x-icon" href="js_icon.ico">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css">
  <link href="https://fonts.googleapis.com/css?family=Ubuntu:400" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.14.0/themes/prism.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.14.0/plugins/line-numbers/prism-line-numbers.min.css">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.1/css/all.css">
  <link rel="stylesheet" href="main.css">
</head>

<body class="container-fluid">
  <h1><i class="fab fa-js-square"></i> Javascript Introduction</h1>
    <p>This file incorporates material from the JS lessons from the course <a href="https://www.udemy.com/modern-javascript-from-the-beginning/" target="blank">Modern JavaScript from the Beginning</a> by Brad Traversy. The notes incorporate material I found to be of interest and/or worth summarizing again for pedagogical purposes. The stated goal of the course is to help web developers become comfortable enough with JS to move completely away from JQuery (except as a dependency), and be better prepared for using frameworks such as Angular or React. The notes reflect this intention.</p>

    <h2>The Console</h2>
      <p>To open the console in Chrome use either <kbd>Ctrl</kbd> <kbd>Shift</kbd> <kbd>J</kbd> or <kbd>F12</kbd>. In addition to <code class="language-javascript">console.log()</code>, one can <code class="language-javascript">console.table({key:value, key:value})</code> to produce a formatted table, <code class="language-javascript">console.error('some error')</code> to output an error, <code class="language-javascript">console.warning('some warning')</code> to output a warning, <code class="language-javascript">console.time('timing') &hellip; console.timeEnd('timing')</code> to output the duration of a bracketed operation, and <code class="language-javascript">console.clear()</code> to clear the console.</p>

    <h2>Variables</h2>
      <p>Variable declarations are marked with <code class="language-javascript">var</code>, <code class="language-javascript">let</code>, or <code class="language-javascript">const</code>; <code class="language-javascript">let</code> replaces <code class="language-javascript">var</code> in ES6. Variables declared with <code class="language-javascript">var</code> and <code class="language-javascript">let</code> can be declared without an initial value, or have their value be reasigned. In contrast, <code class="language-javascript">const</code> must have an initial variable, and its value cannot be reasigned. Variables cannot begin with a number, as it will throw a syntax error. The contents within the value of a variable declared with <code class="language-javascript">const</code> can be modified if it is an array or an object, but cannot be replaced through a reasigned array or object. Use <code class="language-javascript">const</code> for values that should not change, and <code class="language-javascript">let</code> everywhere else. This practice will make one's code more secure and easy to read, as it lets other devs know that a particular value is immutable.</p>

      <p>The reason <code class="language-javascript">var</code> should be avoided is its global mutability at the block level. If the same variable name is declared with <code class="language-javascript">var</code> in the global scope, and within a block-level level scope, the block level can then change the global level. Both <code class="language-javascript">let</code> and <code class="language-javascript">const</code> mitigate this situation. the following code-block illustrates.</p>
      
<pre class="line-numbers"><code class="language-javascript">// Global Scope
var a = 1;
let b = 2;
const c = 3;

// Block-level scope should not change global variables
for(var a = 0; a &lt; 5; a++){
  console.log(`looping ${a}`);
}

// Global var a is now 5
console.log('Global Scope:', a, b, c); // 'Global Scope: 5 2 3'</code></pre>

      <p>An opening bling <code class="language-javascript">$someVar</code> is generally reserved for marking variables in JQuery in DOM manipulation, as the DOM uses the bling as a global identifier. An opening underscore <code class="language-javascript">_someVar</code> can also be used, but is normally reserved for private variables. Multi-word variables use the following conventions.</p>

      <ul>
        <li><code class="language-javascript">someVariable</code>: camelCase; recommended for JS in general</li>
        <li><code class="language-javascript">some_variable</code>: snake_case; common in PHP (double-click will highlight entire variable)</li>
        <li><code class="language-javascript">SomeVariable</code>: PascalCase; marks constructor functions and ES6 classes</li>
        <li><code class="language-javascript">some-variable</code>: lisp-case, kebab-case, spinal-case, etc. (no conventional name); common in URLs, CSS, etc. (double-click will not highlight entire variable)</li>
        <li><code class="language-javascript">somevariable</code>: alllowercase is not recommended</li>
      </ul>

    <h2>datatypes</h2>
      <p>In JS there are two categories that incorporate all datatypes: primitive and reference. Primitive datatypes are stored directly in the location the variable accesses on the stack. Reference datatypes are accessed by reference (not directly assigned to their variable), and are all objects stored on the heap via dynamically allocated memory (e.g., point to a specific memory location). Reference datatypes include objects, arrays, functions, dates, and anything else that can be stored. There are six primitive datatypes.</p>

      <ul>
        <li><code class="language-javascript">String</code></li>
        <li><code class="language-javascript">Number</code> All integers, decimals, floats, etc. are treated as numbers in JS (unlike some languages)</li>
        <li><code class="language-javascript">Boolean</code></li>
        <li><code class="language-javascript">Null</code></li>
        <li><code class="language-javascript">Undefined</code></li>
        <li><code class="language-javascript">Symbol</code> A feature added to ES6.</li>
      </ul>

      <p>JS is a dynamically typed language, meaning that datatypes are associated with their value rather than their variable. This environment allows for a variable with multiple datatypes. Statically typed languages like Java, C++, and C# must first declare a variable's datatype before giving it a value.</p>

      <h3>Type Conversion/Coercion</h3>
        <p>The ability to convert a variable's datatype is desireable. For example, all data provided by a form are strings, so numbers must first be converted to a number type if number manipulation is desired. JS supports three types: to string, to boolean, and to number (<a href="https://medium.freecodecamp.org/js-type-coercion-explained-27ba3d9a2839" target="blank">see this post for more details</a>). Conversion, or coercion, is explicit or implicit. In the former, the dev explicitly converts a datatype. In the latter, JS handles the conversion. Explicit coercion is handled with the following methods. <code class="language-javascript">String()</code> and <code class="language-javascript">.toString()</code> will convert a datatype to a string. <code class="language-javascript">Number()</code> will convert a datatype to an integer if possible, where <code class="language-javascript">String(false)</code> and <code class="language-javascript">String(null)</code> return <code class="language-javascript">0</code>, but <code class="language-javascript">String('someString')</code> returns <code class="language-javascript">NaN</code>, etc. The methods <code class="language-javascript">parseInt()</code> and <code class="language-javascript">parseFloat()</code> work only with strings representing numbers, where the first converts to an integer, and the latter to a decimal. <code class="language-javascript">Boolean()</code> converts any datatype to truthy or falsey values: e.g., <code class="language-javascript">Boolean('')</code> returns <code class="language-javascript">false</code>, while <code class="language-javascript">Boolean('someString')</code> returns <code class="language-javascript">true</code>. The following elements are falsey: <code class="language-javascript">''</code>, <code class="language-javascript">0</code>, <code class="language-javascript">-0</code>, <code class="language-javascript">NaN</code>, <code class="language-javascript">null</code>, <code class="language-javascript">undefined</code>, and <code class="language-javascript">false</code>. Everything else is truthy.</p>

        <p>Implicit coercion happens under a number of circumstances. An undesireable example inadvertantly mixes datatypes and returns an incorrect result: e.g., <code class="language-javascript">'6' + 5</code> returns <code class="language-javascript">'65'</code> rather than <code class="language-javascript">11</code> or <code class="language-javascript">'11'</code>, where JS inherently converts the number to a string and then concatenates the output. Implicit coercion is helpful in a number of circumstances, such as <code class="language-javascript">==</code> or <code class="language-javascript">!=</code> for loose equality versus the strict <code class="language-javascript">===</code>, or <code class="language-javascript">if('someValueExists') {doSomething}</code>.</p>

    <h2>Template Literals</h2>
      <p>Template literals were introduced in ES6, and provide a smoother way of creating template variables in JS and displaying them in HTML. Its basic syntax is simple: <code class="language-javascript">`&lt;html>${someVar}&lt;/html>`</code>, where the doubled diacritical grave accent brackets the HTML and variables across multiple lines. The following code-block illustrates. Note that as it is written, it will overwrite any existing <code class="language-javascript">.html</code> file associated with the <code class="language-javascript">.js</code> file.</p>
        
<pre class="line-numbers"><code class="language-javascript">const firstName = 'Janeel';
const lastName = 'Doe';
const age = 39;
const job = 'Fullstack Developer';
const city = 'Chicago';
let html;

function message(){
  return 'Hi there!'
}

html = `
&lt;ul>
  &lt;li>Name: ${firstName} ${lastName}&lt;/li>
  &lt;li>Age: ${age}&lt;/li>
  &lt;li>Job: ${job}&lt;/li>
  &lt;li>City: ${city}&lt;/li>
  &lt;li>Function: ${message()}&lt;/li>
  &lt;li>Math Operation: ${20 % 3}&lt;/li>
  &lt;li>Ternary Operation: ${age >= 21 ? 'Of Age' : 'Underage'}&lt;/li>
&lt;/ul>
`;

document.body.innerHTML = html; // replaces existing html with unordered list</code></pre>

    <h2>Conditionals</h2>
      <p>The <code class="language-javascript">if(){}</code> statement is useful for error handling and troubleshooting variables. One can simply check whether a variable exists using <code class="language-javascript">if('someVar'){doSomething}</code>, but the check will throw an error if the variable does not exist. Using <code class="language-javascript">typeof</code> provides a workaround that will not throw an error, illustrated in the following code-block. Leaving <code class="language-javascript">id</code> unassigned or commenting it out returns the same result: 'ID does not exist or is undefined.'</p>

<pre class="line-numbers"><code class="language-javascript">let id;

if(typeof id !== 'undefined'){
  console.log(`The ID is ${id}.`)
} else {
  console.log('ID does not exist or is undefined.')
}</code></pre>

    <h2>Functions</h2>
      <p>In ES5 it is necessary to use <code class="language-javascript">if(){}</code> with <code class="language-javascript">typeof</code> to identify undefined arguments, and then assign them a default value. ES6 makes this process much simpler, as illustrated in the following code-block</p>

<pre class="line-numbers"><code class="language-javascript">function greetings(first = 'John', last = 'Doe'){
  // rather than if(typeof first === 'undefined'){first = 'John'};
  return `Greetings ${first} ${last}!`
}
console.log(greetings()); // 'Greetings John Doe!'</code></pre>

      <p>Besides function declarations and expressions, we also have 'immediately invoked function expressions,' or IIFE for short (pronounced 'iffy'; <a href="https://medium.com/@vvkchandra/essential-javascript-mastering-immediately-invoked-function-expressions-67791338ddc6" target="blank">see here for discussion</a>). An IIFE fires immediately, and is useful for holding private variables and private functions. Global variables that should not be modified are safe in an IFFE. They also work well for modular programming patterns. The following code-block illustrates; they possess other syntax as well.</p>

<pre class="line-numbers"><code class="language-javascript">(function(first, last){
  console.log(`Hi there ${first} ${last}, I'm an IIFE!`)
}('Mario', 'Bro')); // 'Hi there Mario Bro, I'm an IIFE!'</code></pre>

    <h2>General Loops</h2>
      <p>The following items are helpful to keep in mind when using loop operations. First, <code class="language-javascript">continue</code> within a loop operation skips the rest of that iteration and continues immediately to the next iteration, while <code class="language-javascript">break</code> immediately stops the loop at that iteration. Second, it is best to use the <code class="language-javascript">.forEach()</code> method with an array, rather than <code class="language-javascript">for(){}</code>. Third, the <code class="language-javascript">for(x in object){}</code> method is useful for iterating through an object's key:value pairs.</p>

    <h2>The Window Object</h2>
      <p>The <code class="language-javascript">window</code> is the global object in client-side JS, regardless of browser. It contains size and scroll information that is useful for firing animations at key points. The <code class="language-javascript">window.location</code> object contains the domain name of the server, search parameters, and so forth. The <code class="language-javascript">window.history</code> object contains navigation history such as number of pages visited and in what order. The <code class="language-javascript">window.navigator</code> object is useful for identifying a client's browser type and version, their human language, their OS, etc.</p>

    <h2>DOM Manipulation and Events</h2>
      <p>The document object model (DOM) is essentially a structured representation of an HTML document, and can be thought of as a tree of elements or nodes created by the browser (e.g., all tags such as <code class="language-javascript">&lt;html></code>, <code class="language-javascript">&lt;body></code>, <code class="language-javascript">&lt;h1></code>, etc.). All of these are located within the <code class="language-javascript">window.document</code> object. The DOM is easily manipulated with vanilla JS, as it each node is an object with its own set of properties and methods. As such, using the JQuery library to manipulate the DOM "is kind of like using a sledgehammer to kill a mosquito." Today's vanilla JS just as capable, and is faster.</p>

      <h3 id="testID" class="testClass">DOM Selectors</h3>
        <p>There are two types of document object selectors. Single selectors grab a single item, even if there are more than one. Multiple selector methods returns an html collection or node list. A collection is array-like and can be converted to an array, while a node list includes more information and can be treated as an array without conversion. The styling and some html content for this section illustrates. The power of these selectors is demonstrated by our ability to make a user's experience with an app dynamic, as well as incorporating data from APIs and Ajax requests.</p>

        <h4></h4>
          <p>The selector <code class="language-javascript">document.querySelector()</code> replaces the older <code class="language-javascript">document.getElementById()</code>, the latter is limited to selecting specific ids. The <code class="language-javascript">querySelector()</code> method uses CSS3 syntax to target specific html elements, whether tags or otherwise, but will only select one at a time. The following list illustrates a bit.</p>

          <ul id="qSelId">
            <li><code class="language-javascript">document.querySelector('h4').style.background = '#7D71B3'</code> selects the first <code class="language-javascript">&lt;h4></code> in the document: the title of this subsection</li>
            <li><code class="language-javascript">document.querySelector('h4').innerHTML = '&lt;span style="background:#FFC096; padding:3px; border-radius:5px;">&lt;code class="language-javascript">document.querySelector()&lt;/code>&lt;/span>'</code> provides the html content and styling for our title</li>
            <li><code class="language-javascript">document.querySelector('#qSelId li:nth-child(2)').style.background = '#FFE7D8'</code> selects the ID of our title and then the specified child: this list item</li>
          </ul>

        <h4><code class="language-javascript">document.querySelectorAll()</code></h4>
          <p>The selectors <code class="language-javascript">document.getElementsByClassName()</code> and <code class="language-javascript">document.getElementsByTagName()</code> will grab all specified classes and html tags, respectively. The <code class="language-javascript">document.querySelectorAll()</code> method is similar, but is both more flexible and returns a node list, which can be treated as an array without conversion. All three can use CSS3 syntax to target more specific html elements. The following list illustrates a bit.</p>

          <ul>
            <li><pre class="line-numbers"><code class="language-javascript">let codeLang = document.getElementsByClassName('language-javascript');
codeLang[99].style.color = 'blue';</code></pre> selects the 99th item in the collection: our subtitle.</li>
            <li><pre class="line-numbers"><code class="language-javascript">let lis = document.getElementsByTagName('li');

lis = Array.from(lis); // convert to array for loop method

lis.forEach(function(li){
  li.style.color = 'white';
});</code></pre> convert collection to array, then use array method to loop: all list text</li>
            <li><pre class="line-numbers"><code class="language-javascript">let liEven = document.querySelectorAll('li:nth-child(even)');

liEven.forEach(function(li){
  li.style.background = '#9690AF';
  li.style.padding = '5px';
  li.style.borderRadius = '5px';
  li.style.margin = '3px 0 3px 0';
});</code></pre> returns node list, use array method without conversion: all even list items</li>
          </ul>

      <h3>Traversing the DOM and Manipulating Elements</h3>
        <p>The previous section also illustrates the process of traversing the DOM. More specific methods involve <code class="language-javascript">document.querySelector()</code> with <code>children</code>, <code>parents</code>, and <code>siblings</code>. When a node list is returned (e.g., via <code class="language-javascript">document.querySelectorAll()</code> or <code class="language-javascript">childNodes</code>), <em>all</em> elements are included, such as the <code class="language-javascript">text</code> element (signifying a line break). Most often collections will be more useful for DOM traversal.</p>

        <p>JS can also be used to create elements, replace them, or remove them altogether. These are illustrated in the following list and the accompanying <code>app.js</code>.</p>

        <ul id="createEl">
          <li>The first item in an illustrative list</li>
          <li>The second item in an illustrative list</li>
        </ul>

    <div class="container-fluid" id="eventContainer">
      <h3>Event Listeners and the Event Object</h3>
        <p>We can use the <code class="language-javascript">document.querySelector()</code> to access a specific DOM element, and then add an event listener with <code class="language-javascript">.addEventListener()</code> to make the UI interactive. The following buttons and form illustrate, followed by a sample of their encoding.</p>

          <h5 id="eventTitle">Events Illustrated</h5>
          <button class="btn btn-outline-info" id="event1">event1 button</button>
          <a class="btn btn-outline-warning" id="event2" href="https://google.com" target="blank">event2 link</a>
          <button class="btn btn-outline-light" id="event3">mouseEvent</button>

          <form class="form-inline formEvent" action="index.php">
            <div class="form-group">
              <label for="keyboardEvent"></label>
              <input type="text" class="form-control" id="keyboardEvent" placeholder="keyboardEvent">
            </div>
            <div class="form-group mx-sm-2">
              <input type="submit" class="btn btn-outline-success" id="submitEvent" value="submitEvent">
            </div>
            <div class="form-group mx-sm-2">
            <select name="selectList" id="selectEvent" class="custom-select">
              <option selected>selectSomething</option>
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3">3</option>
            </select>
            </div>
          </form>

<pre class="line-numbers"><code class="language-javascript">let event1 = document.querySelector('#event1');
let event2 = document.querySelector('#event2');

event1.addEventListener('click', onClick)
event2.addEventListener('click', onClick)

event1.addEventListener('mouseover', onMouseover)
event2.addEventListener('mouseover', onMouseover)

// e is short for event object
function onClick(e){
  // override the default behavior of forms, links, etc.
  // e.g., link button should load google.com on click, but overridden
  e.preventDefault();

  // e.target element: most important element of the event object
  e.target.innerText = 'Did Something!'
  console.log(e.timeStamp);
}

function onMouseover(e){
  e.target.textContent = 'Click Me!';
}</code></pre>
    </div>

      <h3>Event Bubbling and Event Delegation</h3>
        <p>Bubbling represents the firing of an event type on an element, and the subsequent firing of the same type on its parent, and upwards through its remaining ancestors, presuming they have the same event type, all the up to the <code class="language-javascript">document</code> (<a href="https://javascript.info/bubbling-and-capturing" target="blank">modified from this full explanation</a>). The previous section illustrates via the console, where clicking only on the select dropdown fires its click event, then its form, then its form's container div.</p>

        <p>Event delegation represents an event placed on a parent, where logic then dictates which of its child element(s) is influenced. Delegation ensures that event handlers will function for items added to the DOM after it has loaded (i.e., via JS). The following list illustrates, followed by its encoding. The listener is added to the <code class="language-javascript">document</code>, and the logic looks for the target's parent via its id.</p>

        <ul class="deleteMe anotherClass yetAnother">
          <li class="deleteMe anotherClass">Delete me by clicking!</li>
          <li class="deleteMe">Delete me by clicking!</li>
          <li class="deleteMe">Delete me by clicking!</li>
        </ul>
<pre class="line-numbers"><code class="language-javascript">document.body.addEventListener('click', deleteItem);

function deleteItem(e){
  // will work for elements added after DOM loads
  if(e.target.parentElement.classList.contains('deleteMe')){
    console.log('deleted!');
    e.target.remove();
  }
}</code></pre>

    <h2>Local and Session Storage</h2>
      <p>Session storage keeps user information in memory for the duration that an app and/or browser is open. Local storage has a built in set of methods for data persistence, located at <code class="language-javascript">window.localStorage</code>. Data stored in local storage must be manually removed by the user through the app UI or browser settings. Both session and local storage use the same methods, and their data is viewable in the Chrome dev tools under Application, Storage. All items set to local storage must be a string, and it will return a string. Arrays and objects can be stored, etc., via the methods <code class="language-javascript">JSON.stringify()</code> for input, and <code class="language-javascript">JSON.parse()</code> for output. The following list generator illustrates via the console (see its encoding with comments at the conclusion of <code class="language-javascript">app.js</code>). See my <code>listKeeperBasic</code> app for a fuller illustration employing <code class="language-javascript">.localStorage</code>.</p>

      <div class="card">
        <div class="card-body">
          <h5 class="card-title">Task List</h5>
            <form class="form-inline" id="taskForm">
              <div class="form-group">
                <label for="taskNew"></label>
                <input type="text" class="form-control" id="taskNew" placeholder="New Task">
              </div>
              <div class="form-group mx-sm-2">
                <input type="submit" class="btn btn-info" id="taskAdd" value="Add Task">
              </div>
            </form>
            <small>Check the console, silly!</small>
        </div>
      </div>

    <h2>Object Oriented Programming (OOP)</h2>

      <h3>ES5 Syntax</h3>
        <p>An <code>object literal</code> works for any situation that object is entirely unique (e.g., <code class="language-javascript">const uniqueObj = {unique1: String, unique2: etc.}</code>). Wherever objects with similar properties are desired, however, in ES5 it is best to use <code>constructor functions</code> with the <code class="language-javascript">new</code> and <code class="language-javascript">this</code> keywords (see the <code class="language-javascript">new Person(first, last, dob)</code> example in the accompanying <code>app.js</code>). ES6 introduces the <code class="language-javascript">class</code>, which is essentially a wrapper for constructors, and which is meant to reflect the functionality of classes in other languages like Java, C++, and so forth.</p>

        <p>Built in constructors should be accessed through their primitive values, rather than through <code class="language-javascript">new</code>: e.g., <code class="language-javascript">let newStr = 'someNewString'</code>, not <code class="language-javascript">let newStr = new String('someNewString')</code>. Using <code class="language-javascript">new</code> for these items will, of course, return an object, is unecessarily complex, and may potentially cause a performance hit.</p>

        <p>When building objects with constructors, include only properties that are unique. Properties shared by all <code class="language-javascript">new</code> objects from the same constructor should be added to that constructor's <code class="language-javascript">.prototype</code>, which will then link to each <code class="language-javascript">new</code> object's dunder <code class="language-javascript">__proto__</code> (see the <code class="language-javascript">new Person(first, last, dob)</code> example). Such practice results in DRY code, removing repetitive code and the resulting possibility of a performance hit. The constructor's dunder <code class="language-javascript">__proto__</code> is in turn linked to the <code class="language-javascript">Object.prototype</code> in the prototype chain.</p>

        <p>It is also helpful to create new constructors based on existing constructors, if they share properties, with the <code class="language-javascript">call()</code> or <code class="language-javascript">apply()</code> methods. In our <code>app.js</code>, the <code class="language-javascript">Customer()</code> constructor inherits the properties of the <code class="language-javascript">Person()</code> constructor. Note, however, that its <code class="language-javascript">.prototype</code> is <em>not</em> inherited, and must be explicitly added: <code class="language-javascript">Customer.prototype = Object.create(Person.prototype)</code>. The <code class="language-javascript">personProto</code> object used with <code class="language-javascript">Object.create()</code> in the <code>app.js</code> provides an example of a simpler alternative to prototypic inheritance.</p>

      <h3>ES6 Syntax: Classes</h3>
        <p>The <code class="language-javascript">class</code> in ES6 is syntactic sugar, that is, a convenience syntax that makes the creation of constructor functions and working with inheritance easier. As such, it functions similarly to classes in other languages like Java and C#. A <code class="language-javascript">class</code> returns a <code class="language-javascript">constructor</code> and associated methods, as illustrated by the <code class="language-javascript">class Human {&hellip;}</code> in our <code>app.js</code>. The <code class="language-javascript">static</code> method may also be added to a <code class="language-javascript">class</code>, which can only be invoked on the <code class="language-javascript">class</code> itself, not on <code class="language-javascript">new</code> objects created from that class. Such a feature is useful for invoking a function on <em>all</em> objects through their governing <code class="language-javascript">class</code>, such as alphabetizing <code class="language-javascript">new</code> book objects, or removing <code class="language-javascript">class</code> specific items from a DB by id, etc. (see <a href="https://javascript.info/class">Ilya Kantor's explanation of all these points</a> with useful examples; see also the <code class="language-javascript">Cat()</code> class example in <code>app.js</code>).</p>

        <p>The notion of inheritance in the ES6 <code class="language-javascript">class</code> is referred to descriptively as a sub-class. A sub-class is created using the <code class="language-javascript">extends</code> and <code class="language-javascript">super()</code> methods, and represents a streamlined way of creating inheritance among constructor functions. For example, see the <code class="language-javascript">Dog()</code> and <code class="language-javascript">Cat()</code> classes in our <code>app.js</code>, where the latter is an extended sub-class of the former.</p>

    <h2>Asynchronous Code</h2>
      <p>Most web-based asynchronous JS is handled through existing technologies such as AJAX, Fetch, Node.js fs (filesystem), and so forth. What is then important is how we handle their responses, either through callback functions, promises, or async/await.</p>

      <h3>AJAX</h3>
        <p>"Asynchronous JS & XML" (AJAX) is a set of web technologies that allow us to send/receive data asynchronously, and can handle XML (older), JSON ("JS Object Notation"; current standard), and plain text data formatting. That is, it allows the client to interact with a page's server without reloading the page, making the page much faster and interactive. Note that AJAX has been superceded by Fetch.</p>

        <p>The core element of AJAX is the XHR object (<code>XMLHttpRequest</code>), is part of all browsers, has the methods used for data transfer between the client and the server, and can be used by other protocols than HTTP. The Fetch API is a commonly used technology for handling this object, and is native to vanilla JS. External libraries are also used: e.g., Axios, Superagent, jQuery (Brad does not recommend it for this purpose), and Node HTTP. The buttons below illustrate asynchronous interaction with the XHR object in accessing local <code>.txt</code> and <code>.json</code> data, as well as <a href="http://www.icndb.com/api/" target="blank">a simple external API for generating random Chuck Norris jokes</a> (see the <code>app.js</code> for its associated JS).</p>

        <div class="container">
          <button class="btn btn-outline-info" id="xhrBtn">XHR Get TXT</button>
          <button class="btn btn-outline-success" id="xhrCstmr">XHR Get Cstmr JSON</button>
          <button class="btn btn-outline-primary" id="xhrCstmrs">XHR Get Cstmrs JSON</button>
          <br>
          <div id="xhrOutput"></div>
          <div id="xhrOutputCstmr"></div>
          <div id="xhrOutputCstmrs"></div>
        </div>

        <div class="container-fluid CNJokeGenerator">
          <div class="CNTitle">
            <h4>Chuck Norris Joke Generator</h4>
            <small>Warning: these are really, really bad!</small>
          </div>
          <form>
            <div class="form-group row">
              <div class="col-sm-4">
                <input type="number" step="1" class="form-control" id="number" placeholder="Number of Jokes">
              </div>
              <div class="col-sm-8">
                <button class="btn btn-outline-danger btn-block get-jokes">Get Chuck Norris Jokes at Your Own Risk!</button>
              </div>
            </div>
          </form>
          <ul class="CNJokes"></ul>
        </div>

      <h3>RESTful APIs</h3>
        <p>REST stands for "Representational State Transfer," and is a standardized way of using HTTP requests that allow web APIs to Create (POST), Read (GET), Update (PUT), and Delete (DELETE) data (CRUD). Since it is based on the HTTP protocol, one can use any language to use REST and RESTful APIs. Other HTTP requests include HEAD (like GET but returns the header rather than the body), OPTIONS (returns an API's supported HTTP methods), and PATCH (updates partial resources). An HTTP request is sent to a specific endpoint URL to accomplish these methods, and forms the basis of RESTful routing.</p>

      <h3>Callback Functions</h3>
        <p>A callback function is a function that is passed into another function as a parameter. The <code class="language-javascript">.forEach(function callback(){})</code> method illustrates a synchronous callback, and <code class="language-javascript">setTimeout(function callback(){}, milliseconds)</code> method illustrates an asyncronous callback. How callbacks work are illustrated in our <code>app.js</code>.</p>

      <h3>ES6 Promises</h3>
        <p>Promises are an alternative to callbacks for handling asyncronous operations: they promise to do something once another operation is finished, and incorporate built-in error handling. The <code class="language-javascript">Promise()</code> takes <code class="language-javascript">resolve</code> and <code class="language-javascript">reject</code> as arguments for handling a completed function or an error. Instead of a callback it uses <code class="language-javascript">.then()</code>, as well as <code class="language-javascript">.catch()</code> for handling errors generated in the <code class="language-javascript">Promise()</code>. See the refactoring of the callback illustration into a <code class="language-javascript">Promise()</code> in our <code>app.js</code>.</p>

      <h3>The Fetch API</h3>
        <p>The built-in Fetch API returns promises, and is the current replacement for AJAX requests. It is illustrated via the following buttons and their execution in our <code>app.js</code>.</p>

        <div class="container CNTitle">
          <button class="btn btn-outline-info" id="fetch1">Fetch TXT</button>
          <button class="btn btn-outline-success" id="fetch2">Fetch Cstmr JSON</button>
          <button class="btn btn-outline-primary" id="fetch3">Fetch External API Data</button>
          <br>
          <div id="fetchOutput"></div>
        </div>

      <h3>CORS</h3>
        <p>Cross-Origin Resource Sharing (CORS) is a browser-side security feature that works to prevent malicious JS injection client-side. It also successfully prevents fetch/AJAX requests while developing in a local environment, resulting in the dreaded <code>Failed to load https://someAPI.com: No 'Access-Control-Allow-Origin' header is present&hellip;</code>, or its like. This response is <em>not</em> an error, as CORS is doing what it was designed to do. For a helpful overview with practical application see the article <a href="https://medium.com/@baphemot/understanding-cors-18ad6b478e2b" target="blank">"Understanding CORS"</a>. A temporary solution for Chrome devs is to close Chrome, and then restart it from the CLI with the following flags: <code class="language-markup">chrome --disable-web-security --user-data-dir</code>. This will disable CORS for the duration of that session <em>for all web activity</em>, so use with caution (e.g., develop on Chrome but use another browser for everything else during that session).</p>

      <h3>Arrow Functions</h3>
        <p>The arrow function is a simpler way of writing basic functions. Syntax is simple: <code class="language-javascript">function(arg){doSomething()}</code> is replaced by <code class="language-javascript">(arg) => {doSomething()}</code>, or <code class="language-javascript">() => {doSomething()}</code> for no argument. The syntax can be shortened further: no parentheses are needed for a single argument, and functions do not need braces, yielding <code class="language-javascript">arg => doSomething()</code>. No argument and multiple arguments require parentheses; multi-line functions are comma-separated (not semicolon). Note that <code class="language-javascript">return</code> need not be declared as it is implicit, and object literals need parentheses: e.g., <code class="language-javascript">() => ({key: 'value'})</code>. See the refactored Fetch API above in our <code>app.js</code> for a real example. Note as well that unlike regular functions, the arrow function does not have its own <code class="language-javascript">this</code>: in the context of an arrow function <code class="language-javascript">this</code> reflects the lexical scope in which that arrow function appears.</p>

      <h3><code class="language-javascript">async … await</code></h3>
        <p>All modern browsers support <code class="language-javascript">async</code>, <code class="language-javascript">await</code>, and <code class="language-javascript">Promise()</code>, though these methods are not supported in any version of IE. If one's app uses them it is still advisable to recompile into ES5 using Babel, etc., in order to support older browsers. A function preceded by <code class="language-javascript">async</code> returns an implicit promise, which is resolved with a following <code class="language-javascript">.then()</code>. An <code class="language-javascript">async</code> function can be paused internally with <code class="language-javascript">await</code> to wait for the promise's resolution. As such, "the <code class="language-javascript">await</code> keyword is only valid inside <code class="language-javascript">async</code> functions" (MDN). Because <code class="language-javascript">fetch()</code> also returns an implicit promise, <code class="language-javascript">async … await</code> are ideally suited for it (see the example in our <code>app.js</code>).</p>

      <h3><code class="language-javascript">try … catch</code></h3>
        <p>ES6 provides an elegant solution for control in error handling/thrown exceptions: the <code class="language-javascript">try {something} catch(err){someError}</code> block. This block allows us to <code class="language-javascript">catch(e){someError}</code> without stopping the rest of our code from running, which normally occurs when an error is thrown. The block also has an optional <code class="language-javascript">finally {}</code> command that runs something immediately after the <code class="language-javascript">try &hellip; catch</code> block, but before the remaining code. It is used principally to release resources, whether they threw an exception or not, such as closing a file server-side, generically outlined in the following code-block (see <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch" target="blank">MDN</a> for helpful discussion).</p>

<pre class="line-numbers"><code class="language-javascript">openMyFile();
try {
  writeMyFile(withData); // tie up a resource
} catch(e){
  console.log(e); // log thrown exception
} finally {
  closeMyFile(); // always close resource
}</code></pre>

        <p>Global exceptions include the following: <code>ReferenceError</code>, <code>TypeError</code>, <code>SyntaxError</code>, and <code>URIError</code>. Each possesses accessible <code class="language-javascript">name</code> and <code class="language-javascript">message</code> values, and each can be used with <code class="language-javascript">throw new GlobalError('andSomeMessage')</code> to generate an exception. Similarly, this syntax can be used to generate one's own named exception and message, illustrated in the following code-block and our <code>app.js</code> file.</p>

<pre class="line-numbers"><code class="language-javascript">try {
  if(someException){
    // throw a specific error with message
    throw new SyntaxError('someException has occurred!')
  }
} catch(e) {
  // create an error variety for message
  console.log(`UserError: ${e.message}`); // UserError: someException has occurred!
}</code></pre>

    <h2>Regular Expressions</h2>
      <p>Regular expressions (regExp) function similarly accross languages in both form and syntax: they are not unique to JS. RegEx are used to identify patterns for validation, and for pulling information (e.g., email, SS-numbers, credit-card numbers, and so forth). This overview is considered beginner and intermediate level.</p>

      <p>A regExp is bounded by forward slashes, after which flags may appear: e.g., <code class="language-javascript">let re = /hello/ig</code> represents the pattern "hello", where the <code class="language-javascript">i</code> flag makes the match case-insensitive, and the <code class="language-javascript">g</code> flag makes it global (it can return all matches, not just the first). The following methods are commonly used with regExp.</p>

      <table>
        <tr>
          <th>Method</th>
          <th>Explanation</th>
        </tr>
        <tr>
          <td><code class="language-javascript">re.exec('searchString')</code></td>
          <td>where <code class="language-javascript">re</code> is a regExp as a variable; returns an array <code class="language-javascript">['searchString', index: #, input: 'searchedString']</code>, otherwise returns <code class="language-javascript">null</code></td>
        </tr>
        <tr>
          <td><code class="language-javascript">re.test('searchString')</code></td>
          <td>returns the boolean <code class="language-javascript">true</code> or <code class="language-javascript">false</code></td>
        </tr>
        <tr>
          <td><code class="language-javascript">str.match(re)</code></td>
          <td>where <code class="language-javascript">str</code> is the searched string as a variable; also returns an array <code class="language-javascript">['searchString', index: #, input: 'searchedString']</code> or <code class="language-javascript">null</code></td>
        </tr>
        <tr>
          <td><code class="language-javascript">str.search(re)</code></td>
          <td>returns the index of the first match, otherwise returns <code class="language-javascript">-1</code></td>
        </tr>
        <tr>
          <td><code class="language-javascript">str.replace(re, 'replacementString')</code></td>
          <td>returns a new string, where a match is replaced with the <code class="language-javascript">'replacementString'</code></td>
        </tr>
      </table>

      <p>RegExp may contain metacharacters, brackets, braces, parenthesis, and shorthand character classes. The following tables summarize some of these. See <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions" target="blank">MDN</a> for a fuller treatment with examples.</p>

      <table>
        <tr>
          <th>Metacharacter</th>
          <th>Explanation</th>
        </tr>
        <tr>
          <td><code class="language-javascript">/^h/</code></td>
          <td>charat, match must start with 'h'</td>
        </tr>
        <tr>
          <td><code class="language-javascript">/h$/</code></td>
          <td>bling, match must end with 'h'</td>
        </tr>
        <tr>
          <td><code class="language-javascript">/h.llo/</code></td>
          <td>period matches a single character</td>
        </tr>
        <tr>
          <td><code class="language-javascript">/h*llo/</code></td>
          <td>asterisk matches 0 or more characters</td>
        </tr>
        <tr>
          <td><code class="language-javascript">/gre?a?y/</code></td>
          <td>question matches optional characters</td>
        </tr>
        <tr>
          <td><code class="language-javascript">/gre?a?y\?/</code></td>
          <td>backslash escapes metacharacter to literal character</td>
        </tr>
      </table>

      <table>
        <tr>
          <th>Brackets</th>
          <th>Character Sets Explanation</th>
        </tr>
        <tr>
          <td><code class="language-javascript">/gr[ae]y/</code></td>
          <td>must be 'a' or 'e'</td>
        </tr>
        <tr>
          <td><code class="language-javascript">/[GF]ray/</code></td>
          <td>must be 'G' or 'F'</td>
        </tr>
        <tr>
          <td><code class="language-javascript">/[^GF]ray/</code></td>
          <td>match anything but 'G' or 'F'</td>
        </tr>
        <tr>
          <td><code class="language-javascript">/[A-Z]ray/</code></td>
          <td>any uppercase letter</td>
        </tr>
        <tr>
          <td><code class="language-javascript">/[a-z]ray/</code></td>
          <td>any lowercase letter</td>
        </tr>
        <tr>
          <td><code class="language-javascript">/[A-Za-z]ray/</code></td>
          <td>any letter, regardless of case</td>
        </tr>
        <tr>
          <td><code class="language-javascript">/[0-9]/</code></td>
          <td>any number</td>
        </tr>
      </table>

      <table>
        <tr>
          <th>Braces</th>
          <th>Quantifiers Explanation</th>
        </tr>
        <tr>
          <td><code class="language-javascript">/hel{2}o/</code></td>
          <td>'l' must occur <code class="language-javascript">{n}</code> times</td>
        </tr>
        <tr>
          <td><code class="language-javascript">/hel{2,4}o/</code></td>
          <td>'l' must occur in the range of <code class="language-javascript">{n1-n2}</code> times</td>
        </tr>
        <tr>
          <td><code class="language-javascript">/hel{2,}o/</code></td>
          <td>'l' must occur at least <code class="language-javascript">{n}</code> times</td>
        </tr>
        <tr>
          <td><code class="language-javascript">/([0-9]z){3}/</code></td>
          <td>parenthesis provide grouping; here a number followed by 'z' as a group must occur <code class="language-javascript">{n}</code> times</td>
        </tr>
      </table>

      <table>
        <tr>
          <th>Character Class</th>
          <th>Shorthand Explanation</th>
        </tr>
        <tr>
          <td><code class="language-javascript">/\w/</code></td>
          <td>match any alphanumeric character or '_'</td>
        </tr>
        <tr>
          <td><code class="language-javascript">/\w+/</code></td>
          <td>match any alphanumeric character or '_' one or more times</td>
        </tr>
        <tr>
          <td><code class="language-javascript">/\W/</code></td>
          <td>match any non-alphanumeric character</td>
        </tr>
        <tr>
          <td><code class="language-javascript">/\d/</code></td>
          <td>match any numeral</td>
        </tr>
        <tr>
          <td><code class="language-javascript">/\D/</code></td>
          <td>match any non-numeral</td>
        </tr>
        <tr>
          <td><code class="language-javascript">/\s/</code></td>
          <td>match any whitespace (e.g., <kbd>space</kbd>, <kbd>tab</kbd>)</td>
        </tr>
        <tr>
          <td><code class="language-javascript">/\S/</code></td>
          <td>match any non-whitespace</td>
        </tr>
        <tr>
          <td><code class="language-javascript">/hi\b/</code></td>
          <td>marks a word-boundary: e.g., matches 'hi' but not 'hide'</td>
        </tr>
      </table>

      <table>
        <tr>
          <th>Assertions</th>
          <th>Explanation</th>
        </tr>
        <tr>
          <td><code class="language-javascript">/x(?=y)/</code></td>
          <td>match 'x' only if followed by 'y'</td>
        </tr>
        <tr>
          <td><code class="language-javascript">/x(?!y)/</code></td>
          <td>match 'x' only if NOT followed by 'y'</td>
        </tr>
      </table>

      <p>These basic regExp principles and methods are used in <code>app.js</code> with the following form for validating name, zipcode, email, and phone number fields on <code>blur</code>. Name accepts any letters, whitespace, and period, but nothing else (like digits). Zipcode accepts either five or nine digits, with or without a dash or space. Email accepts a typical email pattern, but without spaces, etc. Phone number accepts American phone pattern, with or without parenthesis, spaces, dashes, or dots. These are not all inclusive, are intended only for illustration, and are no replacement for existing libraries.</p>

      <div class="container-fluid formValidation">
        <h3>Form Validation Example</h3>
        <form>
          <div class="form-row">
            <div class="col form-group">
              <label for="name">Name</label>
              <input type="text" class="form-control" id="name" placeholder="Name">
              <div class="invalid-feedback">
                Name must be 2 to 10 characters
              </div>
            </div>
            <div class="col">
              <label for="zip">Zipcode</label>
              <input type="text" class="form-control" id="zip" placeholder="Zipcode">
              <div class="invalid-feedback">
                Enter a valid zipcode
              </div>
            </div>
          </div>
          <div class="form-row">
            <div class="col form-group">
              <label for="email">Email</label>
              <!-- N.B.: type='email' better for HTML5, but here a regExp exercise -->
              <input type="text" class="form-control" id="email" placeholder="Email">
              <div class="invalid-feedback">
                Enter a valid email
              </div>
            </div>
            <div class="col">
              <label for="phone">Phone Number</label>
              <!-- N.B.: type='email' better for HTML5, but here a regExp exercise -->
              <input type="text" class="form-control" id="phone" placeholder="Phone Number">
              <div class="invalid-feedback">
                Enter a valid phone number
              </div>
            </div>
          </div>
        </form>
      </div>

    <h2>Iterators and Generators</h2>
      <p>"[A]n iterator is an object which defines a sequence and potentially a return value upon its termination" (MDN). Iterators use a <code class="language-javascript">next()</code> method that returns an object with the <code class="language-javascript">value</code> of the item in the iteration, and <code class="language-javascript">done</code> as either <code class="language-javascript">false</code> (continue iterating) or <code class="language-javascript">true</code> (all items iterated). Repeatedly calling <code class="language-javascript">next()</code> "consumes" the iterator until <code class="language-javascript">done: true</code>, also the result of all successive calls. While commonly used for iterating over arrays, they are useful for handling objects as well.</p>

      <p>A generator produces similar results but in a simplified way, where the <code class="language-javascript">next()</code> method with its <code class="language-javascript">value</code> and <code class="language-javascript">done</code> properties are implicit. Generators use the following syntax: <code class="language-javascript">function* generatorFunction(){ doSomething until yield; again yield; again yield; etc. }</code>. The following profile scroller provides a practical illustration (see <code>app.js</code>).</p>

    <div class="container-fluid profileScroller">
      <div class="row">
        <div class="col -md-6 mx-auto text-center">
          <h3>profileScroller</h3>
          <div id="imageDisplay"></div>
          <br>
          <div id="profileDisplay"></div>
          <br>
          <button id="next" class="btn btn-outline-info btn-block">Next Profile</button>
          <br>
        </div>
      </div>
    </div>

    <h2>Symbols</h2>
      <p>The <code>symbol</code> is a primitive datatype, and is invoked via <code class="language-javascript">Symbol()</code>. Each invocation is essentially unique, where <code class="language-javascript">Symbol() === Symbol()</code> returns <code>false</code>. Thus, when assigned to a variable, that variable will be unique. Note that <code class="language-javascript">Symbol()</code> does not have a constructor, so we do not use the <code class="language-javascript">new</code> keyword (otherwise it will throw an exception).</p>

<pre class="line-numbers"><code class="language-javascript">const sym1 = Symbol();
const sym2 = Symbol();

console.log(sym1 === sym1); // true
console.log(sym1 === sym2); // false</code></pre>

      <p>A descriptor is optional, which functions to distinguish symbols during trouble-shooting: e.g., <code class="language-javascript">Symbol('sym1')</code>. For normal development, symbols are principally good for avoiding namespace collision, where variables are not accidentally (or intentionally) highjacked through the implementation of libraries, updates, and so forth. The <code>symbol</code> makes a solid alternative to the <code>string</code> and <code>number</code> everywhere a unique value is desireable. See the excellent discussion by Jason Orendorff in <a href="https://hacks.mozilla.org/2015/06/es6-in-depth-symbols/" target="blank">"ES6 in Depth: Symbols."</a></p>

    <h2>Destructuring</h2>
      <p>Destructuring syntax "makes it possible to unpack values from arrays, or properties from objects, into distinct variables" (MDN). While such unpacking is certainly not new, destructuring provides simpler and easier to read syntax for accessing array and object values. Rather than declaring a new variable for each element in an array or object, destructuring allows us to place them on a single line, as illustrated in the following code-block.</p>

<pre class="line-numbers"><code class="language-javascript">const a, b;
[a, b] = [1, 2];
console.log(a, b); // 1 2

// with the spread operator ('rest' can anything)
({ a, b, ...rest} = { a:1, b:2, c:3, d:4, e:5 });
console.log(rest); // {c:3, d:4, e:5}
console.log(rest.d); // 4

// array destructuring
let pets = ['Spot', 'Ash', 'Jumper'];
let [pet1, pet2, pet3] = pets;
console.log(pet1, pet2, pet3); // Spot Ash Jumper

// object destructuring
let person = {
  name: 'Jane Doe',
  age: 55,
  city: 'Tucson',
  sayHello: function(){ console.log("Howdy Pardner!"); }
}

let { name, age, city, sayHello } = person;
console.log(name, age, city); // Jane Doe 55 Tucson
sayHello(); // Howdy Pardner!

// rather than the old way:
let name = person.name,
    age = person.age,
    city = person.city,
    sayHello = person.sayHello;</code></pre>

    <h2>Maps</h2>
      <p>The <code class="language-javascript">Map()</code> function allows us to use <em>any</em> datatype as a key. Thus, it is similar to an <code>object</code>, but does not convert its keys to a <code>string</code>. That is, <code class="language-javascript">Map()</code> can use an <code>object</code> or a <code>function</code> as a key. Map values are set and gotten with the following syntax: <code class="language-javascript">someMap.set(keyVar, 'someValue')</code> and <code class="language-javascript">someMap.get(keyVar) // returns 'someValue'</code>. The number of keys in a map can be obtained via <code class="language-javascript">someMap.size // returns a number</code>. Maps are also iterable using loops. For all of these see the associated <code>app.js</code>.</p>

      <p>Practically speaking, maps alleviate the need to add an identifier such as <code class="language-javascript">{id: id#}</code> to an object, for the object itself functions as the key. The following code-block illustrates (taken from <a href="https://javascript.info/map-set-weakmap-weakset" target="blank">Ilya Kantor's excellent discussion</a>).</p>

<pre class="line-numbers"><code class="language-javascript">// object as key
let john = {name: 'John'};
// for every user store visits count
let visitsCountMap = new Map();
// john is the key for the map
visitsCountMap.set(john, 123);

console.log(visitsCountMap.get(john)); // 123</code></pre>

    <h2>Sets</h2>
      <p>A <code class="language-javascript">Set()</code> is a specific type of object that holds a set of unique values of any datatype. It is without keys, and each value appears only once. We could use an array to find unique elements via the <code class="language-javascript">array.find()</code> method, but it creates a performance hit due to the need to loop through the entire array. The following methods are common: <code class="language-javascript">new Set()</code>, <code class="language-javascript">someSet.add('someValue')</code>, <code class="language-javascript">someSet.size // returns a number</code>, <code class="language-javascript">someSet.has('someValue') // returns a boolean</code>, <code class="language-javascript">someSet.delete('someValue')</code>. Like <code class="language-javascript">Map()</code>, <code class="language-javascript">Set()</code> is iterable, and can be converted into an <code>array</code>.</p>

    <h2>Patterns in JS</h2>
      <p>All languages use patterning at all levels, from a simple block of code up to entire applications. As such they can be thought of as templates designed for any number of situations (e.g., the <code>constructor</code> and <code>prototype</code>). In this section we will examine the following varieties: Module and Revealing Module, Singleton, Factory, Observer, Mediator, and State. For examples of these see <code>app.js</code>.</p>

      <h3>Standard Module Pattern</h3>
        <p>This pattern uses an IIFE for declaring private and public variables and functions. All variations of the Module pattern reminds me of JS classes. The basic form of the Module is as follows:</p>

<pre class="line-numbers"><code class="language-javascript">let someModule = (function(){
  // declare private vars and functions
  let someVar = 'A private variable!'
  let changeVar = function(){
    let someOtherVar = 'Another private variable!';
    someVar = someOtherVar;
  }

  // declare public vars and functions
  return {
    callChangeVar: function(){
      changeVar();
      console.log(someVar);
    }
  }
})();

someModule.callChangeVar(); // Another private variable!
console.log(someModule.someVar); // undefined (variable does not exist)
someModule.changeVar(); // TypeError (function does not exist)</code></pre>

      <h3>Revealing Module Pattern</h3>
        <p>This pattern is a variation on the Module pattern, albeit with an emphasis on public functions as methods. While the Revealing Module is cleaner, the regular Module is more flexible. The following code-block illustrates.</p>

<pre class="line-numbers"><code class="language-javascript">let ItemCtrl = (function(){
  // private var for data manipulation
  let data = [];
  // private function for adding to data
  function add(item){
    data.push(item);
    console.log('Item added.');
  }
  // private function for getting data via id
  function get(id){
    return data.find(item => {
      return item.id === id;
    });
  }

  // public methods for adding and getting
  return {
    add: add,
    get: get
  }
})();

ItemCtrl.add({id: 1, name: 'Jane'}); // Item added.
console.log(ItemCtrl.get(1)); // {id: 1, name: 'Jane'}</code></pre>

      <h3>Singleton Pattern</h3>
        <p>This pattern is also a variation on the Module pattern. It returns only one instance, where repeated invocations result in the same return. Many devs apparently recommend against using this pattern.</p>

      <h3>Factory Pattern</h3>
        <p>This pattern is ideal for producing multiple unique objects that share the same basic structure: the same keys but with different values. An example use case is the creation of user profiles and the like, which share common categories like name, age, email, and so forth.</p>

      <h3>Observer Pattern</h3>
        <p>This pattern </p>

      <h3>Mediator Pattern</h3>
        <p>This pattern </p>

      <h3>State Pattern</h3>
        <p>This pattern </p>

</body>

<footer>
  <script type="text/javascript" src="app.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.14.0/prism.min.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.14.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
</footer>
</html>