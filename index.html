<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>JS Sandbox: Section 2</title>
  <link rel="icon" type="image/x-icon" href="bqd_01-4.ico">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css">
  <link href="https://fonts.googleapis.com/css?family=Ubuntu:400" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.14.0/themes/prism.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.14.0/plugins/line-numbers/prism-line-numbers.min.css">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.1/css/all.css">
  <link rel="stylesheet" href="main.css">
</head>

<body class="container-fluid">
  <h1>JS Sandbox: Section 2</h1>
    <p>This file incorporates material from the introductory JS lessons from the course <a href="https://www.udemy.com/modern-javascript-from-the-beginning/" target="blank">Modern JavaScript from the Beginning</a> by Brad Traversy. The notes incorporate only material I found to be of interest. Brad's stated purpose of the course is to help web developers become comfortable enough with JS to move completely away from JQuery (except as a dependency), and be better prepared for using frameworks such as Angular or React.</p>

    <h2>The Console</h2>
      <p>To open the console in Chrome use either <kbd>Ctrl</kbd> <kbd>Shift</kbd> <kbd>J</kbd> or <kbd>F12</kbd>. In addition to <code class="language-javascript">console.log()</code>, one can <code class="language-javascript">console.table({key:value, key:value})</code> to produce a formatted table, <code class="language-javascript">console.error('some error')</code> to output an error, <code class="language-javascript">console.warning('some warning')</code> to output a warning, <code class="language-javascript">console.time('timing') &hellip; console.timeEnd('timing')</code> to output the duration of a bracketed operation, and <code class="language-javascript">console.clear()</code> to clear the console.</p>

    <h2>Variables</h2>
      <p>Variable declarations are marked with <code class="language-javascript">var</code>, <code class="language-javascript">let</code>, or <code class="language-javascript">const</code>; <code class="language-javascript">let</code> replaces <code class="language-javascript">var</code> in ES6. Variables declared with <code class="language-javascript">var</code> and <code class="language-javascript">let</code> can be declared without an initial value, or have their value be reasigned. In contrast, <code class="language-javascript">const</code> must have an initial variable, and its value cannot be reasigned. Variables cannot begin with a number, as it will throw a syntax error. The contents within the value of a variable declared with <code class="language-javascript">const</code> can be modified if it is an array or an object, but cannot be replaced through a reasigned array or object. Use <code class="language-javascript">const</code> for values that should not change, and <code class="language-javascript">let</code> everywhere else. This practice will make one's code more secure and easy to read, as it lets other devs know that a particular value is immutable.</p>

      <p>The reason <code class="language-javascript">var</code> should be avoided is its global mutability at the block level. If the same variable name is declared with <code class="language-javascript">var</code> in the global scope, and within a block-level level scope, the block level can then change the global level. Both <code class="language-javascript">let</code> and <code class="language-javascript">const</code> mitigate this situation. the following code-block illustrates.</p>
      
<pre class="line-numbers"><code class="language-javascript">// Global Scope
var a = 1;
let b = 2;
const c = 3;

// Block-level scope should not change global variables
for(var a = 0; a &lt; 5; a++){
  console.log(`looping ${a}`);
}

// Global var a is now 5
console.log('Global Scope:', a, b, c); // 'Global Scope: 5 2 3'</code></pre>

      <p>An opening bling <code class="language-javascript">$someVar</code> is generally reserved for marking variables in JQuery in DOM manipulation, as the DOM uses the bling as a global identifier. An opening underscore <code class="language-javascript">_someVar</code> can also be used, but is normally reserved for private variables. Multi-word variables use the following conventions.</p>

      <ul>
        <li><code class="language-javascript">someVariable</code>: camelCase; recommended for JS in general</li>
        <li><code class="language-javascript">some_variable</code>: snake_case; common in PHP (double-click will highlight entire variable)</li>
        <li><code class="language-javascript">SomeVariable</code>: PascalCase; marks constructor functions and ES6 classes</li>
        <li><code class="language-javascript">some-variable</code>: lisp-case, kebab-case, spinal-case, etc. (no conventional name); common in URLs, CSS, etc. (double-click will not highlight entire variable)</li>
        <li><code class="language-javascript">somevariable</code>: alllowercase is not recommended</li>
      </ul>

    <h2>datatypes</h2>
      <p>In JS there are two categories that incorporate all datatypes: primitive and reference. Primitive datatypes are stored directly in the location the variable accesses on the stack. Reference datatypes are accessed by reference (not directly assigned to their variable), and are all objects stored on the heap via dynamically allocated memory (e.g., point to a specific memory location). Reference datatypes include objects, arrays, functions, dates, and anything else that can be stored. There are six primitive datatypes.</p>

      <ul>
        <li><code class="language-javascript">String</code></li>
        <li><code class="language-javascript">Number</code> All integers, decimals, floats, etc. are treated as numbers in JS (unlike some languages)</li>
        <li><code class="language-javascript">Boolean</code></li>
        <li><code class="language-javascript">Null</code></li>
        <li><code class="language-javascript">Undefined</code></li>
        <li><code class="language-javascript">Symbol</code> A feature added to ES6.</li>
      </ul>

      <p>JS is a dynamically typed language, meaning that datatypes are associated with their value rather than their variable. This environment allows for a variable with multiple datatypes. Statically typed languages like Java, C++, and C# must first declare a variable's datatype before giving it a value.</p>

      <h3>Type Conversion/Coercion</h3>
        <p>The ability to convert a variable's datatype is desireable. For example, all data provided by a form are strings, so numbers must first be converted to a number type if number manipulation is desired. JS supports three types: to string, to boolean, and to number (<a href="https://medium.freecodecamp.org/js-type-coercion-explained-27ba3d9a2839" target="blank">see this post for more details</a>). Conversion, or coercion, is explicit or implicit. In the former, the dev explicitly converts a datatype. In the latter, JS handles the conversion. Explicit coercion is handled with the following methods. <code class="language-javascript">String()</code> and <code class="language-javascript">.toString()</code> will convert a datatype to a string. <code class="language-javascript">Number()</code> will convert a datatype to an integer if possible, where <code class="language-javascript">String(false)</code> and <code class="language-javascript">String(null)</code> return <code class="language-javascript">0</code>, but <code class="language-javascript">String('someString')</code> returns <code class="language-javascript">NaN</code>, etc. The methods <code class="language-javascript">parseInt()</code> and <code class="language-javascript">parseFloat()</code> work only with strings representing numbers, where the first converts to an integer, and the latter to a decimal. <code class="language-javascript">Boolean()</code> converts any datatype to truthy or falsey values: e.g., <code class="language-javascript">Boolean('')</code> returns <code class="language-javascript">false</code>, while <code class="language-javascript">Boolean('someString')</code> returns <code class="language-javascript">true</code>. The following elements are falsey: <code class="language-javascript">''</code>, <code class="language-javascript">0</code>, <code class="language-javascript">-0</code>, <code class="language-javascript">NaN</code>, <code class="language-javascript">null</code>, <code class="language-javascript">undefined</code>, and <code class="language-javascript">false</code>. Everything else is truthy.</p>

        <p>Implicit coercion happens under a number of circumstances. An undesireable example inadvertantly mixes datatypes and returns an incorrect result: e.g., <code class="language-javascript">'6' + 5</code> returns <code class="language-javascript">'65'</code> rather than <code class="language-javascript">11</code> or <code class="language-javascript">'11'</code>, where JS inherently converts the number to a string and then concatenates the output. Implicit coercion is helpful in a number of circumstances, such as <code class="language-javascript">==</code> or <code class="language-javascript">!=</code> for loose equality versus the strict <code class="language-javascript">===</code>, or <code class="language-javascript">if('someValueExists') {doSomething}</code>.</p>

    <h2>Template Literals</h2>
      <p>Template literals were introduced in ES6, and provide a smoother way of creating template variables in JS and displaying them in HTML. Its basic syntax is simple: <code class="language-javascript">`&lt;html>${someVar}&lt;/html>`</code>, where the doubled diacritical grave accent brackets the HTML and variables accross multiple lines. The following code-block illustrates. Note that as it is written, it will overwrite any existing <code class="language-javascript">.html</code> file associated with the <code class="language-javascript">.js</code> file.</p>
        
<pre class="line-numbers"><code class="language-javascript">const firstName = 'Janeel';
const lastName = 'Doe';
const age = 39;
const job = 'Fullstack Developer';
const city = 'Chicago';
let html;

function message(){
  return 'Hi there!'
}

html = `
&lt;ul>
  &lt;li>Name: ${firstName} ${lastName}&lt;/li>
  &lt;li>Age: ${age}&lt;/li>
  &lt;li>Job: ${job}&lt;/li>
  &lt;li>City: ${city}&lt;/li>
  &lt;li>Function: ${message()}&lt;/li>
  &lt;li>Math Operation: ${20 % 3}&lt;/li>
  &lt;li>Ternary Operation: ${age >= 21 ? 'Of Age' : 'Underage'}&lt;/li>
&lt;/ul>
`;

document.body.innerHTML = html; // replaces existing html with unordered list</code></pre>

    <h2>Conditionals</h2>
      <p>The <code class="language-javascript">if(){}</code> statement is useful for error handling and troubleshooting variables. One can simply check whether a variable exists using <code class="language-javascript">if('someVar'){doSomething}</code>, but the check will throw an error if the variable does not exist. Using <code class="language-javascript">typeof</code> provides a workaround that will not throw an error, illustrated in the following code-block. Leaving <code class="language-javascript">id</code> unassigned or commenting it out returns the same result: 'ID does not exist or is undefined.'</p>

<pre class="line-numbers"><code class="language-javascript">let id;

if(typeof id !== 'undefined'){
  console.log(`The ID is ${id}.`)
} else {
  console.log('ID does not exist or is undefined.')
}</code></pre>

    <h2>Functions</h2>
      <p>In ES5 it is necessary to use <code class="language-javascript">if(){}</code> with <code class="language-javascript">typeof</code> to identify undefined arguments, and then assign them a default value. ES6 makes this process much simpler, as illustrated in the following code-block</p>

<pre class="line-numbers"><code class="language-javascript">function greetings(first = 'John', last = 'Doe'){
  // rather than if(typeof first === 'undefined'){first = 'John'};
  return `Greetings ${first} ${last}!`
}
console.log(greetings()); // 'Greetings John Doe!'</code></pre>

      <p>Besides function declarations and expressions, we also have 'immediately invoked function expressions,' or IIFE for short (pronounced 'iffy'; <a href="https://medium.com/@vvkchandra/essential-javascript-mastering-immediately-invoked-function-expressions-67791338ddc6" target="blank">see here for discussion</a>). An IIFE fires immediately, and is useful for holding private variables and private functions. Global variables that should not be modified are safe in an IFFE. They also work well for modular programming patterns. The following code-block illustrates; they possess other syntax as well.</p>

<pre class="line-numbers"><code class="language-javascript">(function(first, last){
  console.log(`Hi there ${first} ${last}, I'm an IIFE!`)
}('Mario', 'Bro')); // 'Hi there Mario Bro, I'm an IIFE!'</code></pre>

    <h2>General Loops</h2>
      <p>The following items are helpful to keep in mind when using loop operations. First, <code class="language-javascript">continue</code> within a loop operation skips the rest of that iteration and continues immediately to the next iteration, while <code class="language-javascript">break</code> immediately stops the loop at that iteration. Second, it is best to use the <code class="language-javascript">.forEach()</code> method with an array, rather than <code class="language-javascript">for(){}</code>. Third, the <code class="language-javascript">for(x in object){}</code> method is useful for iterating through an object's key:value pairs.</p>

    <h2>The Window Object</h2>
      <p>The <code class="language-javascript">window</code> is the global object in client-side JS, regardless of browser. It contains size and scroll information that is useful for firing animations at key points. The <code class="language-javascript">window.location</code> object contains the domain name of the server, search parameters, and so forth. The <code class="language-javascript">window.history</code> object contains navigation history such as number of pages visited and in what order. The <code class="language-javascript">window.navigator</code> object is useful for identifying a client's browser type and version, their human language, their OS, etc.</p>

    <h2>DOM Manipulation and Events</h2>
      <p>The document object model (DOM) is essentially a structured representation of an HTML document, and can be thought of as a tree of elements or nodes created by the browser (e.g., all tags such as <code class="language-javascript">&lt;html></code>, <code class="language-javascript">&lt;body></code>, <code class="language-javascript">&lt;h1></code>, etc.). All of these are located within the <code class="language-javascript">window.document</code> object. The DOM is easily manipulated with vanilla JS, as it each node is an object with its own set of properties and methods. As such, using the JQuery library to manipulate the DOM "is kind of like using a sledgehammer to kill a mosquito." Today's vanilla JS just as capable, and is faster.</p>

      <h3 id="testID" class="testClass">DOM Selectors</h3>
        <p>There are two types of document object selectors. Single selectors grab a single item, even if there are more than one. Multiple selector methods returns an html collection or node list. A collection is array-like and can be converted to an array, while a node list includes more information and can be treated as an array without conversion. The styling and some html content for this section illustrates. The power of these selectors is demonstrated by our ability to make a user's experience with an app dynamic, as well as incorporating data from APIs and Ajax requests.</p>

        <h4></h4>
          <p>The selector <code class="language-javascript">document.querySelector()</code> replaces the older <code class="language-javascript">document.getElementById()</code>, the latter is limited to selecting specific ids. The <code class="language-javascript">querySelector()</code> method uses CSS3 syntax to target specific html elements, whether tags or otherwise, but will only select one at a time. The following list illustrates a bit.</p>

          <ul id="qSelId">
            <li><code class="language-javascript">document.querySelector('h4').style.background = '#7D71B3'</code> selects the first <code class="language-javascript">&lt;h4></code> in the document: the title of this subsection</li>
            <li><code class="language-javascript">document.querySelector('h4').innerHTML = '&lt;span style="background:#FFC096; padding:3px; border-radius:5px;">&lt;code class="language-javascript">document.querySelector()&lt;/code>&lt;/span>'</code> provides the html content and styling for our title</li>
            <li><code class="language-javascript">document.querySelector('#qSelId li:nth-child(2)').style.background = '#FFE7D8'</code> selects the ID of our title and then the specified child: this list item</li>
          </ul>

        <h4><code class="language-javascript">document.querySelectorAll()</code></h4>
          <p>The selectors <code class="language-javascript">document.getElementsByClassName()</code> and <code class="language-javascript">document.getElementsByTagName()</code> will grab all specified classes and html tags, respectively. The <code class="language-javascript">document.querySelectorAll()</code> method is similar, but is both more flexible and returns a node list, which can be treated as an array without conversion. All three can use CSS3 syntax to target more specific html elements. The following list illustrates a bit.</p>

          <ul>
            <li><pre class="line-numbers"><code class="language-javascript">let codeLang = document.getElementsByClassName('language-javascript');
codeLang[99].style.color = 'blue';</code></pre> selects the 99th item in the collection: our subtitle.</li>
            <li><pre class="line-numbers"><code class="language-javascript">let lis = document.getElementsByTagName('li');

lis = Array.from(lis); // convert to array for loop method

lis.forEach(function(li){
  li.style.color = 'white';
});</code></pre> convert collection to array, then use array method to loop: all list text</li>
            <li><pre class="line-numbers"><code class="language-javascript">let liEven = document.querySelectorAll('li:nth-child(even)');

liEven.forEach(function(li){
  li.style.background = '#9690AF';
  li.style.padding = '5px';
  li.style.borderRadius = '5px';
  li.style.margin = '3px 0 3px 0';
});</code></pre> returns node list, use array method without conversion: all even list items</li>
          </ul>

      <h3>Traversing the DOM and Manipulating Elements</h3>
        <p>The previous section also illustrates the process of traversing the DOM. More specific methods involve <code class="language-javascript">document.querySelector()</code> with <code class="language-javascript">children</code>, <code class="language-javascript">parents</code>, and <code class="language-javascript">siblings</code>. When a node list is returned (e.g., via <code class="language-javascript">document.querySelectorAll()</code> or <code class="language-javascript">childNodes</code>), <em>all</em> elements are included, such as the <code class="language-javascript">text</code> element (signifying a line break). Most often collections will be more useful for DOM traversal.</p>

        <p>JS can also be used to create elements, replace them, or remove them altogether. These are illustrated in the following list and the accompanying JS file.</p>

        <ul id="createEl">
          <li>The first item in an illustrative list</li>
          <li>The second item in an illustrative list</li>
        </ul>

    <div class="container-fluid" id="eventContainer">
      <h3>Event Listeners and the Event Object</h3>
        <p>We can use the <code class="language-javascript">document.querySelector()</code> to access a specific DOM element, and then add an event listener with <code class="language-javascript">.addEventListener()</code> to make the UI interactive. The following buttons and form illustrate, followed by a sample of their encoding.</p>

          <h5 id="eventTitle">Events Illustrated</h5>
          <button class="btn btn-outline-info" id="event1">event1 button</button>
          <a class="btn btn-outline-warning" id="event2" href="https://google.com" target="blank">event2 link</a>
          <button class="btn btn-outline-light" id="event3">mouseEvent</button>

          <form class="form-inline formEvent" action="index.php">
            <div class="form-group">
              <label for="keyboardEvent"></label>
              <input type="text" class="form-control" id="keyboardEvent" placeholder="keyboardEvent">
            </div>
            <div class="form-group mx-sm-2">
              <input type="submit" class="btn btn-outline-success" id="submitEvent" value="submitEvent">
            </div>
            <div class="form-group mx-sm-2">
            <select name="selectList" id="selectEvent" class="custom-select">
              <option selected>selectSomething</option>
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3">3</option>
            </select>
            </div>
          </form>

<pre class="line-numbers"><code class="language-javascript">let event1 = document.querySelector('#event1');
let event2 = document.querySelector('#event2');

event1.addEventListener('click', onClick)
event2.addEventListener('click', onClick)

event1.addEventListener('mouseover', onMouseover)
event2.addEventListener('mouseover', onMouseover)

// e is short for event object
function onClick(e){
  // override the default behavior of forms, links, etc.
  // e.g., link button should load google.com on click, but overridden
  e.preventDefault();

  // e.target element: most important element of the event object
  e.target.innerText = 'Did Something!'
  console.log(e.timeStamp);
}

function onMouseover(e){
  e.target.textContent = 'Click Me!';
}</code></pre>
    </div>

      <h3>Event Bubbling and Event Delegation</h3>
        <p>Bubbling represents the firing of an event type on an element, and the subsequent firing of the same type on its parent, and upwards through its remaining ancestors, presuming they have the same event type, all the up to the <code class="language-javascript">document</code> (<a href="https://javascript.info/bubbling-and-capturing" target="blank">modified from this full explanation</a>). The previous section illustrates via the console, where clicking only on the select dropdown fires its click event, then its form, then its form's container div.</p>

        <p>Event delegation represents an event placed on a parent, where logic then dictates which of its child element(s) is influenced. Delegation ensures that event handlers will function for items added to the DOM after it has loaded (i.e., via JS). The following list illustrates, followed by its encoding. The listener is added to the <code class="language-javascript">document</code>, and the logic looks for the target's parent via its id.</p>

        <ul class="deleteMe anotherClass yetAnother">
          <li class="deleteMe anotherClass">Delete me by clicking!</li>
          <li class="deleteMe">Delete me by clicking!</li>
          <li class="deleteMe">Delete me by clicking!</li>
        </ul>
<pre class="line-numbers"><code class="language-javascript">document.body.addEventListener('click', deleteItem);

function deleteItem(e){
  // will work for elements added after DOM loads
  if(e.target.parentElement.classList.contains('deleteMe')){
    console.log('deleted!');
    e.target.remove();
  }
}</code></pre>

    <h2>Local and Session Storage</h2>
      <p>Session storage keeps user information in memory for the duration that an app and/or browser is open. Local storage has a built in set of methods for data persistence, located at <code class="language-javascript">window.localStorage</code>. Data stored in local storage must be manually removed by the user through the app UI or browser settings. Both session and local storage use the same methods, and their data is viewable in the Chrome dev tools under Application, Storage. All items set to local storage must be a string, and it will return a string. Arrays and objects can be stored, etc., via the methods <code class="language-javascript">JSON.stringify()</code> for input, and <code class="language-javascript">JSON.parse()</code> for output. The following list generator illustrates via the console (see its encoding with comments at the conclusion of <code class="language-javascript">app.js</code>).</p>

      <div class="card">
        <div class="card-body">
          <h5 class="card-title">Task List</h5>
            <form class="form-inline" id="taskForm">
              <div class="form-group">
                <label for="taskNew"></label>
                <input type="text" class="form-control" id="taskNew" placeholder="New Task">
              </div>
              <div class="form-group mx-sm-2">
                <input type="submit" class="btn btn-info" id="taskAdd" value="Add Task">
              </div>
            </form>
            <small>Check the console, silly!</small>
        </div>
      </div>

</body>

<footer>
  <script type="text/javascript" src="app.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.14.0/prism.min.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.14.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
</footer>
</html>